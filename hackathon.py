# -*- coding: utf-8 -*-
"""hackathon

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nqQJOAsgF97YhUUJRWpYSACEmLpaCsRF

# AI Document Labeler
This project aims to fix the problem of filename mess by generating identifiable human-readable names for ambiguously named documents (e.g.: ``Document(1).pdf, WhatsApp Document 2025-06-28(2).pdf, IMPORTANT.pdf, 1706.03762v1.pdf``, etc.) from document text using IBM Granite.
"""

!pip install "git+https://github.com/ibm-granite-community/utils.git" \
docling langchain langchain_community ibm_watsonx_ai langchain_ibm

import os
from langchain_ibm import WatsonxLLM
from ibm_watsonx_ai import Credentials, APIClient
from ibm_granite_community.notebook_utils import get_env_var


location = "us-south" # forced location for the hackathon, change to your own.
api_key = get_env_var("WATSON_API_KEY") # retrieve API key from environment variables/secrets

credentials = Credentials(
    url=f"https://{location}.ml.cloud.ibm.com",
    api_key=api_key,
)
project_id = "a65229f0-74e5-460a-bfab-a75a8f1780d5" # change to your own project id
client = APIClient(credentials=credentials, project_id=project_id)

"""## Converting PDFs to Docling Documents."""

from docling.document_converter import DocumentConverter, PdfFormatOption
from docling.datamodel.base_models import InputFormat
from docling.datamodel.pipeline_options import PdfPipelineOptions

pdf_pipeline_options = PdfPipelineOptions(
    do_ocr=True,
    generate_picture_images=False,
)
format_options = {
    InputFormat.PDF: PdfFormatOption(pipeline_options=pdf_pipeline_options),
}
converter = DocumentConverter(format_options=format_options)

sources = []
path = "documents/"
dirlist = os.listdir(path)
print(dirlist)
for i in dirlist:
  if i[-4:].lower() == ".pdf":
    sources.append("documents/"+i)
print(sources)
conversions = { source: converter.convert(source=source).document for source in sources }

"""Initialize Granite."""

from ibm_watsonx_ai.metanames import GenTextParamsMetaNames as GenParams
llm = WatsonxLLM(
    model_id="ibm/granite-3-3-8b-instruct",
    url=credentials.get("url"),
    apikey=credentials.get("apikey"),
    project_id=project_id,
    params={
        GenParams.DECODING_METHOD: "greedy",
        GenParams.TEMPERATURE: 0,
        GenParams.MIN_NEW_TOKENS: 5,
        GenParams.MAX_NEW_TOKENS: 250,
        GenParams.STOP_SEQUENCES: ["\n"],
    },
)

"""Test if it's working."""

template = "You are a personal assistant. Respond to the following user interactions in natural language; one sentence per response.\n\n"

print(llm.invoke(template+"How do I watch an MP4?"))

"""Pass it the top portions of the documents and ask it to generate filenames for them."""

template = "Extract the title of the following document. If it does not have a title, generate a concise title for the document, intuitive of the document's content. Respond only with the title.\n\n"
titles = []
for source in sources:
  convdoc = str(conversions[source].export_to_markdown())
  convdoc = convdoc[:min(len(convdoc),12000)]
  print(f"Now processing: {conversions[source].name}: {convdoc[:min(len(convdoc),70)]}...")
  titles.append(llm.invoke(template+"[Document]"+convdoc+"[/Document]"))

import re
for i in range(len(titles)):
  #strip titles from leading and trailing whitespaces
  titles[i] = titles[i].strip()

  #remove filename-illegal characters from string
  illegal_chars = r'[<>:"/\\|?*]'
  titles[i] = re.sub(illegal_chars, '_', titles[i])

  #trim title to max filename length and append extension
  titles[i] = titles[i][:min(len(titles[i]),251)]+".pdf"
titles

"""Backup original filenames and rename."""

import json
backup = {}
for i in range(len(sources)):
  backup[path+titles[i]] = sources[i]
  os.rename(sources[i], path+titles[i])

with open("backup.json", 'w') as json_file:
    json.dump(backup, json_file, indent=4)

print("Files renamed sucessfully. Backup saved as backup.json.")

"""# Recovery Tool."""

def recover(backupfile="backup.json"):
  if input("Are you sure you want to revert filename changes? (y/n)").lower() == 'y':
    backup = {}
    with open(backupfile, 'r') as json_file:
      backup = json.load(json_file)
    for i in backup.keys():
      os.rename(i, backup[i])
recover()